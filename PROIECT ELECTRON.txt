#include <stdio.h>
#include <string.h>
#include <winbgim.h>
#include <iostream>
#include <math.h>
#include <stdlib.h>

using namespace std;

#define BUTTON_NUM 9
#define BUTTON_SIZE 60
#define MAX 100
int COMPONENTS_NUM = 0;
int DELETED=0;

#define PI 3.14159
#define rad15  3.873

#define INPUT 1
#define OUTPUT 2

#define BUTTON_INSERT 1
#define BUTTON_ADDCOMPONENT 2
#define BUTTON_DELETECOMPONENT 3
#define BUTTON_WORKSPACE 4
#define BUTTON_SAVE 5
#define BUTTON_LOAD 6
#define BUTTON_CLEAR 7
#define BUTTON_EXIT 8
#define BUTTON_RESTORE 9
#define BUTTON_BACKTOMENU 10
#define BUTTON_DUPLICATE 11

#define RESISTOR 1
#define ELECTRICAL_CELL 2
#define VOLTMETER 3
#define AMPMETER 4
#define DIODE 5
#define BULB 6
#define CAPACITOR 7
#define FUSE 8
#define TRANSISTOR 9
char* componentNames[9] = {"REZISTOR", "CELULA ELECTRICA", "VOLTMETRU", "AMPERMETRU", "DIODA", "BEC", "CONDENSATOR", "SIGURANTA", "TRANZISTOR"};

FILE* file;

void start_menu();
void backtomenu_announcement();
void exit_announcement();

//==============HELPFUL FUNCTIONS=============================

void parseaza(int n,int x,int y)//AȘER
{

    int copie1=n;
           char t[20]="",s[20]="";int k=0;
            if(copie1==0)
                t[k++]='0';
            else
                {while(copie1)
                {
        t[k++]=copie1%10+'0';
        copie1=copie1/10;

            }
                }
            t[k]=NULL;
            for(int i=0;i<k;i++)
                s[i]=t[k-i-1];
            s[k]=NULL;

           //parseaza(selectedComp->angle,selectedComp->current_angle);
           outtextxy(x-textwidth(s)/2,y-textheight(s)/2,s);

}
void parseaza1(float n,int x,int y)//AȘER
{

    int copie=n/PI*180;
           parseaza(copie,x,y);
}

float clamp(float n, float lower, float upper) {//FLORIN
  return max(lower, min(n, upper));
}

float normalize(float value, float minValue, float maxValue) {//FLORIN
    return clamp((value - minValue)/(maxValue - minValue), 0.00f, 1.00f);
}

bool isMouseInRect(float x, float y, float xSize, float ySize) {//FLORIN
    return (abs(x - mousex()) < xSize) && (abs(y - mousey()) < ySize);
}

//==========================POLAR COORD FUNCTIONS===================================
float rotatePointX(float x, float y, float originX, float originY, float angle) {//FLORIN
    return originX + (x - originX)*cos(-angle) + (y - originY)*sin(-angle);
}

float rotatePointY(float x, float y, float originX, float originY, float angle) {//FLORIN
    return originY - (x - originX)*sin(-angle) + (y - originY)*cos(-angle);
}

void lineAngle(float x1, float y1, float x2, float y2, float originX, float originY, float angle) {//FLORIN
    line(rotatePointX(x1, y1, originX, originY, angle),
         rotatePointY(x1, y1, originX, originY, angle),
         rotatePointX(x2, y2, originX, originY, angle),
         rotatePointY(x2, y2, originX, originY, angle));
}
void rectangleAngle(float originX, float originY, float sizeX, float sizeY, float angle) {//FLORIN
    lineAngle(originX-sizeX, originY-sizeY, originX+sizeX, originY-sizeY, originX, originY, angle);
    lineAngle(originX+sizeX, originY-sizeY, originX+sizeX, originY+sizeY, originX, originY, angle);
    lineAngle(originX+sizeX, originY+sizeY, originX-sizeX, originY+sizeY, originX, originY, angle);
    lineAngle(originX-sizeX, originY+sizeY, originX-sizeX, originY-sizeY, originX, originY, angle);
}

void fillellipseAngle(float x, float y, float sizeX, float sizeY, float originX, float originY, float angle) {//FLORIN
    fillellipse(rotatePointX(x, y, originX, originY, angle),
                rotatePointY(x, y, originX, originY, angle),
                sizeX, sizeY);
}

void circleAngle(float x, float y, float sizeC, float originX, float originY, float angle) {//FLORIN
    circle(rotatePointX(x, y, originX, originY, angle),
           rotatePointY(x, y, originX, originY, angle),
           sizeC);
}

//=====================COMPONENTS=========================
struct Component;

struct node {//BOTH
    int index;

    float x, y;
    int type;
    int nr_connection=0;
    Component* parent = NULL;
    node* connection[256] = {NULL};

};

struct Component {//BOTH
    int index;

    int type = 0;
    float x, y;
    float s;
    float angle = 0;
    Component *next[10]={NULL};

    char text[256]="COMPONENT";
    //char* current_size="";

    int nodeNum = 0;
    node* nodes[5];
} *components[100] = {NULL};

void addNode(Component*& c, float x, float y, int type) {//Mostly FLORIN
    c -> nodes[c->nodeNum] = new node;
    c -> nodes[c->nodeNum] -> index = c -> nodeNum;
    c -> nodes[c->nodeNum] -> x = x;
    c -> nodes[c->nodeNum] -> y = y;
    c -> nodes[c->nodeNum] -> connection[10] = {NULL};
    c -> nodes[c->nodeNum] -> type = type;
    c -> nodes[c->nodeNum] -> parent = c;
    c -> nodeNum++;
}

void addComponent(float x, float y, float s, int type) {//Mostly FLORIN
    components[COMPONENTS_NUM] = new Component;
    components[COMPONENTS_NUM] -> index = COMPONENTS_NUM;

    components[COMPONENTS_NUM] -> x = x;
    components[COMPONENTS_NUM] -> y = y;
    components[COMPONENTS_NUM] -> type = type;

    components[COMPONENTS_NUM] -> s = s;


    if(type == TRANSISTOR) {
        addNode(components[COMPONENTS_NUM], -1, 0, INPUT);
        addNode(components[COMPONENTS_NUM], 0.125, 0.55, OUTPUT);
        addNode(components[COMPONENTS_NUM], 0.125, -0.55, OUTPUT);
    } else {
        addNode(components[COMPONENTS_NUM], -1, 0, INPUT);
        addNode(components[COMPONENTS_NUM], 1, 0, OUTPUT);
    }

    COMPONENTS_NUM++;
}

Component *mouseComp = NULL;
Component *selectedComp = NULL;

node* mouseNode = NULL;

void drawComponent(int type, float x, float y, float fullSize, float angle) {//BOTH
    int s = fullSize * 0.7;

    setfillstyle(SOLID_FILL, WHITE);
    switch(type) {
        case RESISTOR:
            rectangleAngle(x, y, s, s/2, angle);
            lineAngle(x - fullSize, y, x - s, y, x, y, angle);
            lineAngle(x + fullSize, y, x + s, y, x, y, angle);
            fillellipseAngle(x - fullSize, y, 3, 3, x, y, angle);
            fillellipseAngle(x + fullSize, y, 3, 3, x, y, angle);

            break;

        case ELECTRICAL_CELL:
            lineAngle(x - s/6, y + s/4, x - s/6, y - s/4, x, y, angle);
            lineAngle(x + s/6, y - s/2, x + s/6, y + s/2, x, y, angle);
            lineAngle(x - fullSize, y, x - s/6, y, x, y, angle);
            lineAngle(x + fullSize, y, x + s/6, y, x, y, angle);
            fillellipseAngle(x - fullSize, y, 3, 3, x, y, angle);
            fillellipseAngle(x + fullSize, y, 3, 3, x, y, angle);

            break;

        case VOLTMETER:
            circleAngle(x, y, s/2, x, y, angle);
            lineAngle(x, y + s/4, x - s/4, y - s/4, x, y, angle);
            lineAngle(x, y + s/4, x + s/4, y - s/4, x, y, angle);
            lineAngle(x - fullSize, y, x - s/2, y, x, y, angle);
            lineAngle(x + fullSize, y, x + s/2, y, x, y, angle);
            fillellipseAngle(x - fullSize, y, 3, 3, x, y, angle);
            fillellipseAngle(x + fullSize, y, 3, 3, x, y, angle);

            break;

        case AMPMETER:
            circleAngle(x, y, s/2, x, y, angle);
            lineAngle(x, y - s/4, x - s/4, y + s/4, x, y, angle);
            lineAngle(x, y - s/4, x + s/4, y + s/4, x, y, angle);
            lineAngle(x-s/6, y+s/10, x + s/7, y+s/10, x, y, angle);
            lineAngle(x - fullSize, y, x - s/2, y, x, y, angle);
            lineAngle(x + fullSize, y, x + s/2, y, x, y, angle);
            fillellipseAngle(x - fullSize, y, 3, 3, x, y, angle);
            fillellipseAngle(x + fullSize, y, 3, 3, x, y, angle);

            break;

        case DIODE:
            lineAngle(x-s/4,y+s/2,x-s/4,y-s/2, x, y, angle);
            lineAngle(x-s/4,y+s/2,x+s/2,y, x, y, angle);
            lineAngle(x-s/4,y-s/2,x+s/2,y, x, y, angle);
            lineAngle(x+s/2,y-s/2,x+s/2,y+s/2, x, y, angle);
            lineAngle(x-fullSize,y,x-s/4,y, x, y, angle);
            lineAngle(x+fullSize,y,x+s/2,y, x, y, angle);
            fillellipseAngle(x - fullSize, y, 3, 3, x, y, angle);
            fillellipseAngle(x + fullSize, y, 3, 3, x, y, angle);

            break;

        case BULB:
            {circleAngle(x,y,s/2, x, y, angle);
            double alfa=3.14/4;
            lineAngle(x-cos(alfa)*s/2,y+cos(alfa)*s/2,x+cos(alfa)*s/2,y-cos(alfa)*s/2, x, y, angle);
            lineAngle(x+cos(alfa)*s/2,y+cos(alfa)*s/2,x-cos(alfa)*s/2,y-cos(alfa)*s/2, x, y, angle);
            lineAngle(x-fullSize,y,x-s/2,y, x, y, angle);
            lineAngle(x+fullSize,y,x+s/2,y, x, y, angle);
            fillellipseAngle(x - fullSize, y, 3, 3, x, y, angle);
            fillellipseAngle(x + fullSize, y, 3, 3, x, y, angle);

            }
            break;

        case CAPACITOR:
            for(int i=-1;i<=1;i++)
                lineAngle(x-s/3+i,y+s/2,x-s/3+i,y-s/2, x, y, angle);
            for(int i=-1;i<=1;i++)
                lineAngle(x+s/3+i,y+s/2,x+s/3+i,y-s/2, x, y, angle);
            lineAngle(x-fullSize,y,x-s/3,y, x, y, angle);
            lineAngle(x+fullSize,y,x+s/3,y, x, y, angle);
            fillellipseAngle(x-fullSize,y,3,3, x, y, angle);
            fillellipseAngle(x+fullSize,y,3,3, x, y, angle);

            break;

        case FUSE:
            for(int i=0;i<=1;i++)
            rectangleAngle(x, y, s+i, s/2+i, angle);
            for(int i=0;i<=1;i++)
                lineAngle(x-fullSize,y+i,x+fullSize,y+i, x, y, angle);
            fillellipseAngle(x - fullSize, y, 3, 3, x, y, angle);
            fillellipseAngle(x + fullSize, y, 3, 3, x, y, angle);

            break;

        case TRANSISTOR:
            {double R=s*0.65;
            circleAngle(x,y,R, x, y, angle);
            lineAngle(x-R/2,y+R/2,x-R/2,y-R/2, x, y, angle);
            lineAngle(x-R/2,y+R/4,x+R/4,y+rad15*R/4, x, y, angle);
            lineAngle(x+R/4,y+rad15*R/4,x+R/4,y+s*0.8, x, y, angle);
            lineAngle(x-R/2,y-R/4,x+R/4,y-rad15*R/4, x, y, angle);
            lineAngle(x+R/4,y-rad15*R/4,x+R/4,y-s*0.8, x, y, angle);
            lineAngle(x-fullSize,y,x-R/2,y, x, y, angle);
            fillellipseAngle(x-fullSize,y,3,3, x, y, angle);
            fillellipseAngle(x+R/4,y+s*0.8,2,2, x, y, angle);
            fillellipseAngle(x+R/4,y-s*0.8,2,2, x, y, angle);

            }
            break;
    }

}

void drawConnection(float x1, float y1, float x2, float y2) {//FLORIN
    if(x2 < x1) {
        line(x1, y1, x1, y1 + (y2-y1)/2);
        line(x1, y1 + (y2-y1)/2, x2, y1 + (y2-y1)/2);
        line(x2, y1 + (y2-y1)/2, x2, y2);

        return;
    }

    line(x1, y1, x1 + (x2-x1)/2, y1);
    line(x1 + (x2-x1)/2, y1, x1 + (x2-x1)/2, y2);
    line(x1 + (x2-x1)/2, y2, x2, y2);
}
//======================BUTTON==============================

struct Button {//FLORIN
    float x, y;
    char text[25];

    int type = 0;
    int insertType = 0;

    float sizeX, sizeY;

    bool isActive = false;
    bool isVisible = true;
} *buttons[BUTTON_NUM], *insertButton, *exitButton, *deleteButton, *saveButton, *loadButton, *workspaceButton, *clearButton,*backtomenuButton,*duplicateButton;

Button* initButton(char *s, float x, float y, float sizeX, float sizeY, float type, float insertType) {//FLORIN
    Button* b = new Button;
    b->x = x;
    b->y = y;
    b->sizeX = sizeX;
    b->sizeY = sizeY;
    b->type = type;
    b->insertType = insertType;
    strcpy(b->text, s);

    return b;
}

Button* initButton(char *s, float x, float y, float sizeX, float sizeY, float type) {//FLORIN
    return initButton(s, x, y, sizeX, sizeY, type, 0);
}

void checkMouseButton(Button* b) {//BOTH
    if(!b -> isVisible) return;

    switch(b->type) {
        case BUTTON_INSERT://FLORIN
            if(isMouseInRect(b -> x, b -> y, b->sizeX, b->sizeY)) {
                b->isActive = true;
            }

            if(b->isActive && !isMouseInRect(60, 300, 60, 300)) {
                b->isActive = false;
            }

            for(int i = 0; i < BUTTON_NUM; i++) {
                buttons[i]->isVisible = b->isActive;
            }

        break;

        case BUTTON_ADDCOMPONENT://FLORIN
            if(ismouseclick(WM_LBUTTONDOWN) && isMouseInRect(b -> x, b -> y, b->sizeX, b->sizeY)) {
                //clearmouseclick(WM_LBUTTONDOWN);
                addComponent(b->x,b->y, 50, b->insertType);
                strcpy(components[COMPONENTS_NUM-1]->text,b->text);
                insertButton->isActive = false;
            }
        break;

        case BUTTON_DELETECOMPONENT://BOTH
            if(ismouseclick(WM_LBUTTONDOWN)&& isMouseInRect(b->x, b->y, b->sizeX,b->sizeY)) {
                clearmouseclick(WM_LBUTTONDOWN);
                if(selectedComp) {
                    for(int i = 0; i < COMPONENTS_NUM; i++) {
                        if(components[i] == selectedComp) {

                            for(int j = 0; j < components[i]->nodeNum; j++) {
                                for(int k = 0; k < components[i]->nodes[j]->nr_connection; k++) {

                                    if(components[i] -> nodes[j] -> connection[k] != NULL) {
                                        for(int l = 0; l < components[i]->nodes[j]->connection[k]->nr_connection; l++) {
                                            if(components[i] -> nodes[j] -> connection[k] -> connection[l] == components[i] -> nodes[j]) {
                                                for(int li = l; li < components[i]->nodes[j]->connection[k]->nr_connection - 1; li++) {
                                                    components[i] -> nodes[j] -> connection[k] -> connection[li] = components[i] -> nodes[j] -> connection[k] -> connection[li+1];
                                                }
                                                components[i] -> nodes[j] -> connection[k] -> nr_connection--;
                                            }
                                        }
                                        components[i] -> nodes[j] -> connection[k] = NULL;
                                    }
                                }
                            }

                            //delete components[i];

                            for(int j = i; j < COMPONENTS_NUM-1; j++) {
                                components[j] = components[j+1];
                            }

                            COMPONENTS_NUM--;
                            selectedComp = NULL;
                            return;
                        }
                    }
                }
            }
        break;

        case BUTTON_WORKSPACE://FLORIN
            if(isMouseInRect(b -> x, b -> y, b->sizeX, b->sizeY)) {
                b->isActive = true;
            }

            if(b->isActive && !isMouseInRect(300, 120, 60, 120)) {
                b->isActive = false;
            }

            saveButton->isVisible = b->isActive;
            loadButton->isVisible = b->isActive;
            clearButton->isVisible = b->isActive;

        break;

        case BUTTON_SAVE://FLORIN
            if(ismouseclick(WM_LBUTTONDOWN) && isMouseInRect(b -> x, b -> y, b->sizeX, b->sizeY)) {
                clearmouseclick(WM_LBUTTONDOWN);

                file = fopen("saveFile","w+");
                fprintf(file, "%d\n", COMPONENTS_NUM);
                for(int i = 0; i < COMPONENTS_NUM; i++) {
                    fprintf(file, "%d %f %f %f %f\n", components[i]->type, components[i]->x, components[i]->y, components[i]->angle, components[i]->s);
                }
                for(int i = 0; i < COMPONENTS_NUM; i++) {
                    for(int j = 0; j < components[i] -> nodeNum; j++) {
                        if(components[i]->nodes[j]->type == OUTPUT) {
                            for(int l = 0; l < components[i]->nodes[j]->nr_connection; l++) {
                                fprintf(file, "%d %d %d %d\n", components[i]->index, components[i]->nodes[j]->index, components[i]->nodes[j]->connection[l]->parent->index, components[i]->nodes[j]->connection[l]->index);
                            }
                        }
                    }
                }

                fclose(file);
            }

        break;

        case BUTTON_LOAD://FLORIN
            if(ismouseclick(WM_LBUTTONDOWN) && isMouseInRect(b -> x, b -> y, b->sizeX, b->sizeY)) {
                clearmouseclick(WM_LBUTTONDOWN);

                file = fopen("saveFile","r+");
                if(file == NULL) return;
                rewind(file);


                for(int i = 0; i < COMPONENTS_NUM; i++) {
                    components[i] = NULL;
                }
                COMPONENTS_NUM = 0;
                selectedComp = NULL;

                int num;
                fscanf(file, "%d\n", &num);
                for(int i = 0; i < num; i++) {
                    int t = 0; float x, y, a, s;
                    fscanf(file, "%d %f %f %f %f\n", &t, &x, &y, &a, &s);

                    addComponent(x, y, s, t);
                    components[COMPONENTS_NUM-1]->angle = a;
                }

                while(!feof(file)) {
                    int a, an, b, bn;
                    fscanf(file, "%d %d %d %d\n", &a, &an, &b, &bn);
                    node* aNode = components[a]->nodes[an];
                    node* bNode = components[b]->nodes[bn];
                    aNode->connection[aNode->nr_connection++] = bNode;
                    bNode->connection[bNode->nr_connection++] = aNode;
                }

                fclose(file);
            }
        break;

        case BUTTON_CLEAR://FLORIN
            if(ismouseclick(WM_LBUTTONDOWN) && isMouseInRect(b -> x, b -> y, b->sizeX, b->sizeY)) {
                clearmouseclick(WM_LBUTTONDOWN);

                for(int i = 0; i < COMPONENTS_NUM; i++) {
                    components[i] = NULL;
                }
                COMPONENTS_NUM = 0;
                selectedComp = NULL;
            }
        break;

        case BUTTON_EXIT://AȘER
            if(ismouseclick(WM_LBUTTONDOWN) && isMouseInRect(b -> x, b -> y, b->sizeX, b->sizeY)) {
                clearmouseclick(WM_LBUTTONDOWN);
                exit_announcement();
            }
        break;
        /*case BUTTON_RESTORE:
            if(ismouseclick(WM_LBUTTONDOWN)&& isMouseInRect(b->x, b->y, b->sizeX,b->sizeY))

                {
                        clearmouseclick(WM_LBUTTONDOWN);
                        b->isActive=true;
                        //circle(50,50,100);
                }
            if(b->isActive &&!isMouseInRect(b->x,b->y,b->sizeX,b->sizeY))
                b->isActive=false;
        break;
        */
        case BUTTON_BACKTOMENU://AȘER
             if(ismouseclick(WM_LBUTTONDOWN)&&isMouseInRect(b->x,b->y,b->sizeX,b->sizeY))
             {
                 swapbuffers();
                 cleardevice();
                 backtomenu_announcement();

             }
        break;
        case BUTTON_DUPLICATE://AȘER
        if(ismouseclick(WM_LBUTTONDOWN)&& isMouseInRect(b->x, b->y, b->sizeX,b->sizeY)) {
                clearmouseclick(WM_LBUTTONDOWN);
                   if(selectedComp)
                   {
                      addComponent(60,100,50,selectedComp->type);
                      components[COMPONENTS_NUM-1]->nodeNum=selectedComp->nodeNum;
                      for(int j=0;j<selectedComp->nodeNum;j++)
                        components[COMPONENTS_NUM-1]->nodes[j]->nr_connection=selectedComp->nodes[j]->nr_connection;
                       for(int i = 0; i < COMPONENTS_NUM-1; i++) {
                        if(components[i] == selectedComp) {

                            for(int j = 0; j < components[i]->nodeNum; j++) {
                                for(int k = 0; k < components[i]->nodes[j]->nr_connection; k++) {
                                        components[COMPONENTS_NUM-1]->nodes[j]->connection[k]=components[i]->nodes[j]->connection[k];}
                            }
                        }
                       else
                       {
                        for(int a=0;a<selectedComp->nodeNum;a++)
                           for(int j = 0; j < components[i]->nodeNum; j++) {
                                for(int k = 0; k < components[i]->nodes[j]->nr_connection; k++)
                                    if(components[i]->nodes[j]->connection[k]==selectedComp->nodes[a])
                                        components[i]->nodes[j]->connection[(components[i]->nodes[j]->nr_connection)++]=components[COMPONENTS_NUM-1]->nodes[a];
                       }
                       }

                    //circle(50,100,40);

                   }
        }
    }

        break;

    }
}

void drawButton(Button* b) {//FLORIN
    if(!b -> isVisible) return;

    setfillstyle(SOLID_FILL, BLACK);
    bar(b -> x - b->sizeX,
        b -> y - b->sizeY,
        b -> x + b->sizeX,
        b -> y + b->sizeY);

    setlinestyle(SOLID_LINE, 0, 2);
    setcolor(LIGHTGREEN);
    rectangle(b -> x - b->sizeX,
              b -> y - b->sizeY,
              b -> x + b->sizeX,
              b -> y + b->sizeY);

    setlinestyle(SOLID_LINE, 0, 1);
    rectangle(b -> x - b->sizeX + 2,
              b -> y - b->sizeY + 2,
              b -> x + b->sizeX - 3,
              b -> y + b->sizeY - 3);

    if(b->type == BUTTON_ADDCOMPONENT) {
        drawComponent(b->insertType, b->x, b->y, (b->sizeX)*0.75, 0);
    } else {

        outtextxy(b->x-textwidth(b->text)/2,b->y-textheight(b->text)/2,b->text);
    }

    if(isMouseInRect(b->x, b->y, b->sizeX,b->sizeY) && b->type == BUTTON_ADDCOMPONENT) {
        setfillstyle(SOLID_FILL, BLACK);
        bar(b->x + 70, b->y-20, b->x+250, b->y+20);
        setlinestyle(SOLID_LINE, 0, 2);
        rectangle(b->x + 70, b->y-20, b->x+250, b->y+20);
        outtextxy(b->x + 160-textwidth(b->text)/2,b->y-textheight(b->text)/2,b->text);
    }
}

//======================SLIDER===============================//FLORIN

struct Slider {
    float x, y;
    float s;

    float minValue = 0, value = 0, maxValue = 0;
    float step = 0;
    bool isSelected = false;
} *sizeSlider, *angleSlider;

Slider* initSlider(float x, float y, float s, float minValue, float maxValue) {
    Slider *slider = new Slider;
    slider->x = x;
    slider->y = y;
    slider->s = s;
    slider->minValue = minValue;
    slider->maxValue = maxValue;

    return slider;
}

void checkMouseSlider(Slider* slider) {
    if(isMouseInRect(slider->x, slider->y, slider->s/2, 50)) {
        slider -> isSelected = true;
    }
}

bool moveMouseSlider(Slider* slider) {
    if(slider->isSelected) {
        float d = slider->minValue + 0.01 + (slider->maxValue - slider->minValue)*normalize(mousex(), slider->x - slider->s/2, slider->x + slider->s/2+1);

        if(slider -> step != 0) slider -> value = floor(d*slider->step)/slider->step;
        else slider -> value = d;

        return true;
    }
    return false;
}

void drawSlider(Slider* slider) {
    if(selectedComp) {
        int s = (slider -> s)/2;
        setlinestyle(SOLID_LINE, 0, 3);
        setcolor(WHITE);
        line(slider -> x - s, slider -> y, slider -> x + s, slider -> y);
        setlinestyle(SOLID_LINE, 0, 1);
        setfillstyle(SOLID_FILL, BLACK);
        fillellipse(slider -> x - s + s*2*normalize(slider->value, slider->minValue, slider->maxValue), slider -> y, 10, 10);
    }
}

//================================================================================

void checkMouse() {//BOTH
    int x = mousex();
    int y = mousey();

    for(int i = 0; i < BUTTON_NUM; i++) {
        checkMouseButton(buttons[i]);
    }
    checkMouseButton(insertButton);
    checkMouseButton(exitButton);
    checkMouseButton(deleteButton);
    checkMouseButton(saveButton);
    checkMouseButton(loadButton);
    checkMouseButton(clearButton);
    checkMouseButton(workspaceButton);
    checkMouseButton(backtomenuButton);
    checkMouseButton(duplicateButton);

    if(insertButton->isActive) return;

    if(mouseNode != NULL) {
        Component* c = mouseNode -> parent;

        if(mouseNode -> type == OUTPUT) {
            drawConnection(rotatePointX(c->x + mouseNode->x * c->s, c->y + mouseNode->y * c->s, c -> x, c -> y, c -> angle),
                           rotatePointY(c->x + mouseNode->x * c->s, c->y + mouseNode->y * c->s, c -> x, c -> y, c -> angle),
                           mousex(),
                           mousey());
        } else {
            drawConnection(mousex(),
                           mousey(),
                           rotatePointX(c->x + mouseNode->x * c->s, c->y + mouseNode->y * c->s, c -> x, c -> y, c -> angle),
                           rotatePointY(c->x + mouseNode->x * c->s, c->y + mouseNode->y * c->s, c -> x, c -> y, c -> angle));
        }

        if(ismouseclick(WM_LBUTTONUP)) {
            clearmouseclick(WM_LBUTTONUP);

            for(int i = 0; i < COMPONENTS_NUM; i++) {
                for(int j = 0; j < components[i] -> nodeNum; j++) {
                    Component* c = components[i];
                    node* n = c -> nodes[j];

                    int nX = rotatePointX(c->x + n->x * c->s, c->y + n->y * c->s, c -> x, c -> y, c -> angle);
                    int nY = rotatePointY(c->x + n->x * c->s, c->y + n->y * c->s, c -> x, c -> y, c -> angle);

                    if(isMouseInRect(nX, nY, 20, 20) && n->type != mouseNode->type && c != mouseNode->parent) {

                        for(int l = 0; l < n->nr_connection; l++) {
                            if(n->connection[l] == mouseNode) {
                                mouseNode = NULL;
                                return;
                            }
                        }

                        mouseNode -> connection[mouseNode->nr_connection++] = n;
                        n -> connection[n->nr_connection++] = mouseNode;

                        mouseNode = NULL;
                        return;
                    }
                }
            }

            mouseNode = NULL;
            return;
        }
    }

    for(int i = 0; i < COMPONENTS_NUM && mouseComp == NULL; i++) {
        for(int j = 0; j < components[i] -> nodeNum; j++) {
            Component* c = components[i];
            node* n = c -> nodes[j];

            int nX = rotatePointX(c->x + n->x * c->s, c->y + n->y * c->s, c -> x, c -> y, c -> angle);
            int nY = rotatePointY(c->x + n->x * c->s, c->y + n->y * c->s, c -> x, c -> y, c -> angle);

            if(isMouseInRect(nX, nY, 20, 20)) {
                if(mouseNode != NULL && (mouseNode -> type == n -> type || mouseNode -> parent == c)) setfillstyle(SOLID_FILL, RED);
                else setfillstyle(SOLID_FILL, GREEN);

                fillellipse(nX, nY, 10, 10);
                line(nX - 6, nY, nX + 4, nY);
                if(n -> type == OUTPUT) line(nX, nY - 5, nX, nY + 5);

                if(ismouseclick(WM_LBUTTONDOWN)) {
                    clearmouseclick(WM_LBUTTONDOWN);
                    mouseNode = n;
                }

                if(ismouseclick(WM_RBUTTONDOWN)) {
                    clearmouseclick(WM_RBUTTONDOWN);
                    mouseNode = NULL;

                    for(int i = 0; i < n->nr_connection; i++) {
                        for(int j = 0; j < n->connection[i]->nr_connection; j++) {
                            if(n -> connection[i] -> connection[j] == n) {
                                for(int ji = j; ji < n->connection[i]->nr_connection - 1; ji++) {
                                    n -> connection[i] -> connection[ji] = n -> connection[i] -> connection[ji+1];
                                }
                                n -> connection[i] -> nr_connection--;
                            }
                        }
                        n -> connection[i] = NULL;
                    }
                    n->nr_connection = 0;

                    return;
                }

                return;
            }

        }
    }

    if(ismouseclick(WM_LBUTTONUP)) {
        mouseComp = NULL;
        mouseNode = NULL;
        clearmouseclick(WM_LBUTTONUP);
        sizeSlider -> isSelected = false;
        angleSlider -> isSelected = false;

        return;
    }

    if(ismouseclick(WM_LBUTTONDOWN)) {
        clearmouseclick(WM_LBUTTONDOWN);

        for(int i = 0; i < COMPONENTS_NUM; i++) {


            if(isMouseInRect(components[i] -> x, components[i] -> y, components[i] -> s, components[i] -> s/2)) {
                selectedComp = mouseComp = components[i];
                sizeSlider -> value = selectedComp -> s;
                angleSlider -> value = selectedComp -> angle;
                return;
            }
        }

        if(!mouseComp && y < getmaxy() - BUTTON_SIZE) {
            selectedComp = NULL;
        }
        if(selectedComp)
        {checkMouseSlider(sizeSlider);
         checkMouseSlider(angleSlider);}
    }
        // checkMouseButton(duplicateButton);}



    if(mouseComp) {
        if(x > (mouseComp -> s) && x < getmaxx() - (mouseComp -> s)) {
            mouseComp -> x = x;
        }

        if(y > BUTTON_SIZE + (mouseComp -> s)/2 && y < getmaxy() - BUTTON_SIZE - (mouseComp -> s)/2) {
            mouseComp -> y = y;
        }
    }

    if(moveMouseSlider(sizeSlider)) {
        selectedComp -> s = sizeSlider -> value;
    }

    if(moveMouseSlider(angleSlider)) {
        selectedComp -> angle = angleSlider -> value;
    }





}

void initialize() {//BOTH
    insertButton = initButton("Insert", 60, 30, 60, 30, BUTTON_INSERT);
    exitButton =   initButton("Exit", getmaxx()-60, 30, 60, 30, BUTTON_EXIT);
    deleteButton = initButton("Delete", 180, 30, 60, 30, BUTTON_DELETECOMPONENT);

    workspaceButton = initButton("Workspace", 300, 30, 60, 30, BUTTON_WORKSPACE);
    saveButton = initButton("Save", 300, 90, 60, 30, BUTTON_SAVE);
    loadButton = initButton("Load", 300, 150, 60, 30, BUTTON_LOAD);
    clearButton = initButton("Clear", 300, 210, 60, 30, BUTTON_CLEAR);

    backtomenuButton = initButton("Back to Menu",getmaxx()-180,30,60,30,BUTTON_BACKTOMENU);
    duplicateButton = initButton("Duplicate",420,30,60,30,BUTTON_DUPLICATE);

    for(int i = 0; i < BUTTON_NUM; i++) {
        buttons[i] = initButton(componentNames[i], 60, 90+60*i, 60, 30, BUTTON_ADDCOMPONENT, i+1);
        buttons[i]->isVisible = false;
    }

    sizeSlider = initSlider(getmaxx() - 150, getmaxy() - BUTTON_SIZE/2, 150, 40, 100);
    angleSlider = initSlider(getmaxx() - 350, getmaxy() - BUTTON_SIZE/2, 150, 0, PI*2);
    angleSlider -> step = 2.54647908947;
}

void draw() {//BOTH
    setcolor(WHITE);
    setcolor(LIGHTGREEN);
    line(0, BUTTON_SIZE, getmaxx(), BUTTON_SIZE);
    for(int i=0;i<=10;i++)
    {
        if(i%3==1) setcolor(LIGHTGREEN);
        else setcolor(GREEN);
        line(0, getmaxy() - BUTTON_SIZE+i, getmaxx(), getmaxy() - BUTTON_SIZE+i);
    }
    setcolor(DARKGRAY);

    setcolor(WHITE);
    //DRAW COMPONENTS
    for(int i = 0; i < COMPONENTS_NUM; i++) {
        for(int j = 0; j < components[i] -> nodeNum; j++) {
            for(int k = 0; k < components[i]->nodes[j]->nr_connection; k++) {
                if(components[i]->nodes[j]->connection[k] != NULL && components[i]->nodes[j]->type == OUTPUT) {
                    Component* c1 = components[i];
                    node* n1 = c1 -> nodes[j];
                    node* n2 = n1 -> connection[k];
                    Component* c2 = n2->parent;

                    setcolor(WHITE);
                    drawConnection(rotatePointX(c1->x + n1->x * c1->s, c1->y + n1->y * c1->s, c1 -> x, c1 -> y, c1 -> angle),
                                   rotatePointY(c1->x + n1->x * c1->s, c1->y + n1->y * c1->s, c1 -> x, c1 -> y, c1 -> angle),
                                   rotatePointX(c2->x + n2->x * c2->s, c2->y + n2->y * c2->s, c2 -> x, c2 -> y, c2 -> angle),
                                   rotatePointY(c2->x + n2->x * c2->s, c2->y + n2->y * c2->s, c2 -> x, c2 -> y, c2 -> angle));
                }
            }
        }


        if(selectedComp == components[i]) {
           outtextxy(75-textwidth(selectedComp->text)/2,getmaxy()-20-textheight(selectedComp->text)/2,selectedComp->text);
           outtextxy(75+textwidth(selectedComp->text)/2+40-textwidth("SIZE:")/2,getmaxy()-20-textheight("SIZE:")/2,"SIZE:");
           parseaza(selectedComp->s,75+textwidth(selectedComp->text)/2+textwidth("SIZE:")+40,getmaxy()-20);
           outtextxy(75+textwidth(selectedComp->text)/2+40+textwidth("SIZE:")+100-textwidth("ANGLE:")/2,getmaxy()-20-textheight("ANGLE:")/2,"ANGLE:");
           //parseaza(0,75+textwidth(selectedComp->text)/2+40+textwidth("SIZE:")+100+textwidth("ANGLE:")+40,getmaxy()-20);
           parseaza1(selectedComp->angle,75+textwidth(selectedComp->text)/2+40+textwidth("SIZE:")+100+textwidth("ANGLE:")+10,getmaxy()-20);
            setcolor(GREEN);
        } else setcolor(WHITE);

        drawComponent(components[i] -> type, components[i] -> x, components[i] -> y, components[i] -> s, components[i] -> angle);
    }

    //DRAW SLIDER
    drawSlider(sizeSlider);
    drawSlider(angleSlider);

    //DRAW BUTTONS
    for(int i = 0; i < BUTTON_NUM; i++) {
        drawButton(buttons[i]);
    }
    drawButton(insertButton);
    drawButton(exitButton);
    drawButton(deleteButton);
    drawButton(saveButton);
    drawButton(loadButton);
    drawButton(workspaceButton);
    drawButton(clearButton);
    drawButton(backtomenuButton);
    drawButton(duplicateButton);
}
// DRAW MENU//AȘER

void stea_regulata(int n,int xc,int yc,float alfa,int R)
{
    float beta=2*3.14159265/n;
    int x[MAX],y[MAX];
    for(int i=0;i<=n;i++)
      if(i%2==0)
    {
        x[i]=xc+R*cos(alfa+i*beta);
        y[i]=yc+R*sin(alfa+i*beta);
    }
    else
    {
        x[i]=xc+(R/2)*cos(alfa+i*beta);
        y[i]=yc+(R/2)*sin(alfa+i*beta);
    }
    for(int i=0;i<n;i++)
        line(x[i],y[i],x[i+1],y[i+1]);
}
char *announce[2]={"Nu uita sa salvezi continutul. Doresti sa mergi la meniu?",
                   "Nu uita sa salvezi continutul. Doresti sa iesi din aplicatie?"};
void draw_stele()
{
    for(int i=25;i<=1150;i+=75)
     {
        for(int j=1;j<=15;j++)
        {
            if(j%3==1) setcolor(LIGHTGREEN);
            else setcolor(GREEN);
            stea_regulata(12,i,775,0,j);}
     }
}

void draw_body()
{
    for(int i=0;i<=10;i++)
        {
            if(i%3==1) setcolor(LIGHTGREEN);
            else setcolor(GREEN);
            rectangle(400-i,100-i,800+i,150+i);
        }

     for(int i=0;i<=7;i++)
     {
         if(i%3==1) setcolor(LIGHTGREEN);
            else setcolor(GREEN);
            rectangle(450-i,200-i,550+i,250+i);
     }
     outtextxy(500-textwidth("NU")/2,225-textheight("NU")/2,"NU");

     for(int i=0;i<=7;i++)
     {
         if(i%3==1) setcolor(LIGHTGREEN);
            else setcolor(GREEN);
            rectangle(650-i,200-i,750+i,250+i);
     }
      outtextxy(700-textwidth("DA")/2,225-textheight("DA")/2,"DA");
      for(int i=0;i<=25;i++)
     {
         if(i%3==1) setcolor(LIGHTGREEN);
         else setcolor(GREEN);
         line(0,750-i,1200,750-i);}
      draw_stele();

}

void exit_announcement()
{
    while(1)
    {
        draw_body();
        outtextxy(600-textwidth(announce[1])/2,125-textheight(announce[1])/2,announce[1]);
     if(ismouseclick(WM_LBUTTONDOWN))
     {
         clearmouseclick(WM_LBUTTONDOWN);
         if(abs(500-mousex())<50&&abs(225-mousey())<25)
         {
             swapbuffers();
             cleardevice();
             return;
         }
         if(abs(700-mousex())<50&&abs(225-mousey())<25)
         {
             swapbuffers();
             cleardevice();
             for(int i=0;i<COMPONENTS_NUM;i++)
                components[i]=NULL;
             COMPONENTS_NUM=0;
             exit(0);
             return;
         }
     }

      swapbuffers();
      cleardevice();
    }
    getch();

}


void backtomenu_announcement()
{
    while(1)
    {
     draw_body();
     outtextxy(600-textwidth(announce[0])/2,125-textheight(announce[0])/2,announce[0]);
     if(ismouseclick(WM_LBUTTONDOWN))
     {
         clearmouseclick(WM_LBUTTONDOWN);
         if(abs(500-mousex())<50&&abs(225-mousey())<25)
         {
             swapbuffers();
             cleardevice();
             return;
         }
         if(abs(700-mousex())<50&&abs(225-mousey())<25)
         {
             swapbuffers();
             cleardevice();
             for(int i=0;i<COMPONENTS_NUM;i++)
                components[i]=NULL;
             COMPONENTS_NUM=0;
             start_menu();
             return;
         }
     }

      swapbuffers();
      cleardevice();
    }
    getch();

}

char* componentInfo[9]={"Rezistorul este o piesa componenta din circuitele electrice a carei principala proprietate este rezistenta electrica,masurata in ohmi.",
                        "Acest tip de celule electrice sunt utilizate pentru producerea si distributia curentului; puncte de conexiune si de alimentare.",
                        "Voltmetrul este un aparat electric folosit pentru masurarea tensiunii electrice sau a diferentei de potential dintre doua puncte din circuit.",
                        "Ampermetrul este un aparat de masurare a intensitatii curentului electric ce trece printr-un conductor sau un circuit electric.",
                        "Dioda permite trecerea unui curent electric intr-o directie,blocand simultan trecerea curentului in directia opusa.",
                        "Becul electric este o lampa electrica cu incandescenta care produce lumina la trecerea curentului electric printr-un filament.",
                        "Este un dispozitiv ce inmagazineaza energie electrica intre doua armaturi incarcate cu o sarcina electrica egala, dar de semn opus.",
                        "Sigurantele electrice sunt dispozitive de protectie la intreruperea circuitului electric atunci cand curentul depaseste o anumita valoare.",
                        "Tranzistorul este un dispozitiv electronic folosit mai ales pentru a amplifica si a comuta semnale electronice si putere electrica."};

void info_menu()
{
    while(1)
    {
        for(int i=0;i<=5;i++)
        {
            if(i%3==1) setcolor(LIGHTGREEN);
            else setcolor(GREEN);
            rectangle(5-i,5-i,95+i,45+i);
        }
     outtextxy(50-textwidth("BACK")/2,25-textheight("BACK")/2,"BACK");
     for(int i=0;i<=5;i++)
     {
         if(i%3==1) setcolor(LIGHTGREEN);
         else setcolor(GREEN);
         rectangle(1105-i,5-i,1195+i,45+i);}
     outtextxy(1150-textwidth("EXIT")/2,25-textheight("EXIT")/2,"EXIT");

     for(int i=0;i<=25;i++)
     {
         if(i%3==1) setcolor(LIGHTGREEN);
         else setcolor(GREEN);
         line(0,750-i,1200,750-i);}

     draw_stele();
     if(ismouseclick(WM_LBUTTONDOWN))
     {
         clearmouseclick(WM_LBUTTONDOWN);

          if(abs(50-mousex())<45 && abs(25-mousey())<20)
         {swapbuffers();
         cleardevice();
        return;}
          if(abs(1150-mousex())<45&&abs(25-mousey())<20)
          {
              exit(0);
          }
         //cleardevice();
        // return;

     }
     setcolor(WHITE);
     for(int i = 0; i < BUTTON_NUM; i++) {
        drawComponent(buttons[i]->insertType, buttons[i]->x+170, buttons[i]->y+20, (buttons[i]->sizeX)*0.75, 0);
        outtextxy(buttons[i]->x+50-textwidth(buttons[i]->text)/2,buttons[i]->y+20-textheight(buttons[i]->text)/2,buttons[i]->text);
        outtextxy(buttons[i]->x+700-textwidth(componentInfo[i])/2,buttons[i]->y+20-textheight(componentInfo[i])/2,componentInfo[i]);
     }
     char* nota_informativa[1]={"IMPORTANT: Legaturile ce pleaca dintr-un nod al unei componente se pot sterge,apasand click-dreapta pe acel nod."};
      outtextxy(buttons[BUTTON_NUM-1]->x+600-textwidth(nota_informativa[0])/2,buttons[BUTTON_NUM-1]->y+80-textheight(nota_informativa[0])/2,nota_informativa[0]);
     swapbuffers();
     cleardevice();
     setcolor(GREEN);
    }
    getch();

}

void start_menu()
{
    swapbuffers();
    cleardevice();

    while(1)
    {

        setcolor(GREEN);
    for(int i=0;i<=20;i++)
        {   if(i%3==1) setcolor(LIGHTGREEN);
            else setcolor(GREEN);
            rectangle(500-i,75-i,700+i,125+i);
        }
    outtextxy(600-textwidth("ELECTRON")/2,100-textheight("ELECTRON")/2,"ELECTRON");
    for(int i=0;i<=5;i++)
     {   if(i%3==1) setcolor(LIGHTGREEN);
         else setcolor(GREEN);
         rectangle(500-i,200-i,700+i,250+i);
     }
    outtextxy(600-textwidth("START")/2,225-textheight("START")/2,"START");
    for(int i=0;i<=5;i++)
        {
            if(i%3==1) setcolor(LIGHTGREEN);
            else setcolor(GREEN);
            rectangle(525-i,260-i,675+i,310+i);
        }
    outtextxy(600-textwidth("INFO")/2,285-textheight("INFO")/2,"INFO");
    for(int i=0;i<=5;i++)
        {
            if(i%3==1) setcolor(LIGHTGREEN);
            else setcolor(GREEN);
            rectangle(550-i,320-i,650+i,370+i);
        }
    outtextxy(600-textwidth("EXIT")/2,345-textheight("EXIT")/2,"EXIT");

    for(int i=0;i<=25;i++)
     {
         if(i%3==1) setcolor(LIGHTGREEN);
         else setcolor(GREEN);
         line(0,750-i,1200,750-i);}

    draw_stele();
    for(int i=0;i<=25;i++)
    {
        if(i%3==1) setcolor(LIGHTGREEN);
         else setcolor(GREEN);
        line(0,i,1200,i);
        line(i,0,i,750);
        line(1175+i,0,1175+i,750);
    }

    if(ismouseclick(WM_LBUTTONDOWN)&& abs(600-mousex())<100 && abs(225-mousey())<25)
    {
         clearmouseclick(WM_LBUTTONDOWN);
         swapbuffers();
         cleardevice();
         return;
    }
    if(ismouseclick(WM_LBUTTONDOWN) )
    {
        clearmouseclick(WM_LBUTTONDOWN);
        if(abs(600-mousex())<75 && abs(285-mousey())<25)
        {swapbuffers();
        cleardevice();
        info_menu();
        swapbuffers();
        cleardevice();}
        if(abs(600-mousex())<50&&abs(345-mousey())<25)
        {
            exit(0);
        }
    }

    swapbuffers();
    cleardevice();
    }

}

int main() {//BOTH
    initwindow(1200,800, "ELECTRON");

    initialize();
    start_menu();

    while(1) {
        draw();

        checkMouse();

        swapbuffers();
        cleardevice();
    }

    getch(); closegraph(); return 0;
}
